{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"DeepFlow: Physics-Informed Neural Networks for Fluid Dynamics","text":"<p>DeepFlow is a user-friendly framework for solving partial differential equations (PDEs), such as the Navier-Stokes equations, using Physics-Informed Neural Networks (PINNs). It provides a CFD-solver-style workflow to make PINN-based simulations accessible and straightforward.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u27c1 Physics-Attached Geometry: AUTO GENERATE TRAINING DATA by explicitly attach physics and neural network to geometries.</li> <li>\ud83d\udd27 CFD-Solver Style: Straightforward workflow similar to CFD software.</li> <li>\ud83d\udcca Built-in Visualization: Tools to evaluate and plot results.</li> <li>\ud83d\ude80 GPU Acceleration: Enable GPU for faster training.</li> <li>Flexible Domain Definition: Easily define complex 2D geometries.</li> </ul>"},{"location":"#current-implementations","title":"Current Implementations","text":"<ul> <li>Supported problems: solving forward partial differential equations (PDEs)<ul> <li>transient &amp; steady 2D imcompressible Navier-Stokes equations, 2D Fourier Heat equation, Burgers' equation</li> </ul> </li> <li>Sampling methods: Uniform, Random, Latin Hypercube Sampling, RAR-G [0], R3 [1]</li> <li>2D Geometries: Custom functions, Rectangle, Circle, Polygon, and combinations &amp; subtractions.</li> <li>Hard Boundary Conditions: Automatic Hard BC w.r.t. to geometry.</li> <li>Neural Network Architectures: Fully connected feedforward networks (FNN).</li> <li>Optimizers: Adam, L-BFGS</li> <li>Backend: PyTorch</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install DeepFlow via pip:</p> <pre><code>pip install deepflow\n</code></pre> <p>For development or to build from source:</p> <pre><code>git clone https://github.com/YoYo-XYZ/deepflow.git\ncd deepflow\npip install -e .\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python &gt;= 3.8</li> <li>PyTorch &gt;= 1.7.0</li> <li>NumPy &gt;= 1.19.0</li> <li>Matplotlib &gt;= 3.3.0</li> <li>SymPy &gt;= 1.5.0</li> <li>SciPy &gt;= 1.5.0</li> <li>Ultrplot &gt;= 1.0.0</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Check out the Quick Start guide to simulate Steady channel flow under 20 lines of code!</p>"},{"location":"#examples","title":"Examples","text":"<p>See Examples for more use cases including Burgers' Equation, Heat Equation, and Cavity Flow.</p>"},{"location":"#deepflow-milestones","title":"DeepFlow Milestones","text":"<p>...</p>"},{"location":"burgers_eq/","title":"1D Burgers Equation DEMO code","text":"<p>This notebook demonstrates solving 1D Burgers Equation (spatial xy version) using PINNs.</p> <pre><code>import deepflow as df\nprint(\"Deepflow is runned on:\", df.device) # to change to cpu use df.device = 'cpu'\ndf.manual_seed(69) # for reproducibility\n</code></pre> <pre><code>Deepflow is runned on: cuda\n</code></pre>"},{"location":"burgers_eq/#1-define-geometry-domain","title":"1. Define Geometry Domain","text":"<p>Set up the computational domain</p> <pre><code>area = df.geometry.rectangle([-1, 1], [0, 1])\nline_ic = df.geometry.line_horizontal(y=0, range_x=[-1,1])\nline_bc1 = df.geometry.line_vertical(x=-1, range_y=[0,1])\nline_bc2 = df.geometry.line_vertical(x=1, range_y=[0,1])\ndomain = df.domain(area.area_list, line_ic, line_bc1, line_bc2)\ndomain.show_setup()\n</code></pre> <p></p>"},{"location":"burgers_eq/#2-define-physics","title":"2. Define Physics","text":"<p>Define the Burgers eq (spatial version) apply boundary conditions.</p> <pre><code># Define PDE\nfrom torch import sin, pi\ndomain.area_list[0].define_pde(df.pde.BurgersEquation1D(nu=0.01/pi))\ndomain.bound_list[0].define_bc({'u':['x', lambda x: -sin(pi * x)]})\ndomain.bound_list[1].define_bc({'u': 0})\ndomain.bound_list[2].define_bc({'u': 0})\n</code></pre>"},{"location":"burgers_eq/#2-generate-training-data","title":"2. Generate Training Data","text":"<p>Sample initial points for training. After sampling, Deepflow will automatically generate training datasets based on the defined physics.</p> <pre><code># Sample points: [Left, Bottom, Right, Top], [Interior]\ndomain.sampling_lhs([2000, 1000, 1000], [4000])\ndomain.show_coordinates(display_physics=True)\n</code></pre> <p></p>"},{"location":"burgers_eq/#3-train-the-model","title":"3. Train the Model","text":"<p>Define the resampling scheme during training. R3 scheme is recommended.</p> <pre><code>def do_in_adam(epoch, model):\n    if epoch % 500 == 0 and epoch &gt; 0:\n        domain.sampling_R3([2000, 1000, 1000], [4000])\n        print(domain)\n\ndef do_in_lbfgs(epoch, model):\n    if epoch % 100 == 0 and epoch &gt; 0:\n        domain.sampling_R3([2000, 1000, 1000], [4000])\n        print(domain)\n</code></pre> <p>Train the model using Adam optimizer followed by L-BFGS optimizer.</p> <pre><code>model0 = df.PINN(input_vars=['x', 'y'], output_vars=['u'], width=16, length=4)\n\nmodel1, model1_best = model0.train_adam(\n    calc_loss = df.calc_loss_simple(domain),\n    learning_rate=0.015,\n    epochs=4000,\n    do_between_epochs=do_in_adam)\n</code></pre> <pre><code>Epoch: 1, total_loss: 0.63708, bc_loss: 0.63691, pde_loss: 0.00018\nEpoch: 200, total_loss: 0.10178, bc_loss: 0.05901, pde_loss: 0.04277\nEpoch: 400, total_loss: 0.07294, bc_loss: 0.04452, pde_loss: 0.02842\nnumber of bound : ['0: 3065', '1: 1693', '2: 1482']\nnumber of area : ['0: 5407']\nEpoch: 600, total_loss: 0.10885, bc_loss: 0.07805, pde_loss: 0.03080\nEpoch: 800, total_loss: 0.01511, bc_loss: 0.00641, pde_loss: 0.00870\nEpoch: 1000, total_loss: 0.01650, bc_loss: 0.00472, pde_loss: 0.01178\nnumber of bound : ['0: 3800', '1: 2198', '2: 1813']\nnumber of area : ['0: 6625']\nEpoch: 1200, total_loss: 0.01325, bc_loss: 0.00356, pde_loss: 0.00969\nEpoch: 1400, total_loss: 0.00802, bc_loss: 0.00367, pde_loss: 0.00435\nnumber of bound : ['0: 4617', '1: 2747', '2: 2254']\nnumber of area : ['0: 7925']\nEpoch: 1600, total_loss: 0.00648, bc_loss: 0.00290, pde_loss: 0.00358\nEpoch: 1800, total_loss: 0.00302, bc_loss: 0.00102, pde_loss: 0.00201\nEpoch: 2000, total_loss: 0.00735, bc_loss: 0.00360, pde_loss: 0.00375\nnumber of bound : ['0: 5493', '1: 3284', '2: 2527']\nnumber of area : ['0: 8984']\nEpoch: 2200, total_loss: 0.00176, bc_loss: 0.00045, pde_loss: 0.00131\nEpoch: 2400, total_loss: 0.00930, bc_loss: 0.00278, pde_loss: 0.00652\nnumber of bound : ['0: 6255', '1: 3747', '2: 2913']\nnumber of area : ['0: 9964']\nEpoch: 2600, total_loss: 0.02079, bc_loss: 0.00154, pde_loss: 0.01925\nEpoch: 2800, total_loss: 0.00742, bc_loss: 0.00078, pde_loss: 0.00664\nEpoch: 3000, total_loss: 0.00273, bc_loss: 0.00114, pde_loss: 0.00159\nnumber of bound : ['0: 6923', '1: 4220', '2: 3455']\nnumber of area : ['0: 10893']\nEpoch: 3200, total_loss: 0.00098, bc_loss: 0.00024, pde_loss: 0.00074\nEpoch: 3400, total_loss: 0.00073, bc_loss: 0.00017, pde_loss: 0.00056\nnumber of bound : ['0: 7651', '1: 4733', '2: 3835']\nnumber of area : ['0: 11927']\nEpoch: 3600, total_loss: 0.01580, bc_loss: 0.00201, pde_loss: 0.01380\nEpoch: 3800, total_loss: 0.00503, bc_loss: 0.00171, pde_loss: 0.00332\nEpoch: 4000, total_loss: 0.04200, bc_loss: 0.01015, pde_loss: 0.03185\nnumber of bound : ['0: 8525', '1: 5214', '2: 4219']\nnumber of area : ['0: 12743']\n</code></pre> <pre><code>model2 = model1_best.train_lbfgs(calc_loss = df.calc_loss_simple(domain), epochs=500, do_between_epochs=do_in_lbfgs)\n</code></pre> <pre><code>Epoch: 3945, total_loss: 0.00049, bc_loss: 0.00009, pde_loss: 0.00041\nEpoch: 3995, total_loss: 0.00002, bc_loss: 0.00000, pde_loss: 0.00002\nTraining interrupted by user.\n</code></pre> <pre><code>domain.show_coordinates(display_physics=False)\n</code></pre> <p></p>"},{"location":"burgers_eq/#4-visualization","title":"4. Visualization","text":"<pre><code># Evaluate the best model\nprediction = domain.area_list[0].evaluate(model2)\n# Sampling uniform points\nprediction.sampling_area([500, 250])\n</code></pre>"},{"location":"burgers_eq/#41-visualize-pde-area","title":"4.1 Visualize PDE area","text":"<pre><code># Plot Velocity Field\nprediction.plot_color('u', cmap = 'jet', s=0.3).savefig('u_field.png')\n_ = prediction.plot_color('pde_residual', cmap = 'rainbow', s=0.3)\n_ = prediction.plot('pde_residual')\n_ = prediction.plot_loss_curve(log_scale=True)\n</code></pre>"},{"location":"burgers_eq/#42-visualize-u-at-y-075","title":"4.2 Visualize u at y = 0.75","text":"<pre><code>line = df.geometry.line_horizontal(y=0.75, range_x=[-1, 1])\nprediction = line.evaluate(model2)\nprediction.sampling_line(500)\n_ = prediction.plot(y_axis = 'u')\n</code></pre>"},{"location":"cavity_flow/","title":"Steady Channel Flow (Cavity)","text":"<p>This notebook demonstrates solving steady-state Cavity Flow with the same setup as this Comsol blog.</p>"},{"location":"cavity_flow/#1-define-geometry-domain","title":"1. Define Geometry Domain","text":"<p>Set up the computational domain.</p> <pre><code>import deepflow as df\nprint(\"Deepflow is runned on:\", df.device) # to change to cpu use df.device = 'cpu'\ndf.manual_seed(69) # for reproducibility\n\nrectangle = df.geometry.rectangle([0, 1], [0, 1])\ndomain = df.domain(rectangle)\ndomain.show_setup()\n</code></pre> <p>(Output skipped)</p>"},{"location":"cavity_flow/#2-define-physics","title":"2. Define Physics","text":"<p>Define the Navier-Stokes equations for fluid flow and apply boundary conditions (e.g., no-slip walls, inlet velocity).</p> <pre><code>domain.bound_list[0].define_bc({'u': 0,'v': 0})\ndomain.bound_list[1].define_bc({'u': 0,'v': 0})\ndomain.bound_list[2].define_bc({'u': 0,'v': 0})\ndomain.bound_list[3].define_bc({'u': 1, 'v': 0})\ndomain.area_list[0].define_pde(df.NavierStokes(U=0.0001, L=1, mu=0.001, rho=1000))\ndomain.show_setup()\n</code></pre> <p>Sample initial points for training.</p> <pre><code>domain.sampling_lhs(bound_sampling_res=[1000, 1000, 1000, 1000], area_sampling_res=[2000])\ndomain.show_coordinates(display_physics=False)\n</code></pre>"},{"location":"cavity_flow/#3-train-the-pinn-model","title":"3. Train the PINN model","text":"<p>Define how collocation points are sampled during training.</p> <pre><code>def do_in_adam(epoch, model):\n    return\n\ndef do_in_lbfgs(epoch, model):\n    if epoch % 100 == 0 and epoch &gt; 0:\n        domain.sampling_R3(bound_sampling_res=[1000, 1000, 1000, 1000], area_sampling_res=[2000])\n        print(domain)\n</code></pre> <p>Train the model using Adam for initial training (faster convergence).</p> <pre><code>model0 = df.PINN(width=50, length=5, input_vars=['x','y'], output_vars=['u','v','p'])\n\n# Train the model\nmodel1, model1best = model0.train_adam(\n    learning_rate=0.004,\n    epochs=2000,\n    calc_loss=df.calc_loss_simple(domain),\n    threshold_loss=0.05,\n    do_between_epochs=do_in_adam)\n</code></pre> <p>Refine the model using LBFGS for higher precision.</p> <pre><code># Train the model\nmodel2 = model1best.train_lbfgs(\n    calc_loss=df.calc_loss_simple(domain),\n    epochs=450,\n    threshold_loss=0.0005,\n    do_between_epochs=do_in_lbfgs)\n</code></pre>"},{"location":"cavity_flow/#4-visualization","title":"4. Visualization","text":""},{"location":"cavity_flow/#41-visualize-area","title":"4.1 Visualize area","text":"<pre><code>df.Visualizer.refwidth_default = 4\n\n# Create object for evaluation\narea_eval = domain.area_list[0].evaluate(model2)\n# Sampling uniform points\narea_eval.sampling_area([200, 200])\n\narea_eval['v_mag'] = (area_eval['u']**2 + area_eval['v']**2)**0.5\n\n_ = area_eval.plot_color('v_mag', s=4, cmap='jet')\n_ = area_eval.plot_color('u', s=4, cmap='rainbow')\n_ = area_eval.plot_color('v', s=4, cmap='rainbow')\n_ = area_eval.plot_color('p', s=4, cmap='rainbow')\n_ = area_eval.plot_streamline('u', 'v', cmap = 'jet')\n</code></pre>"},{"location":"cavity_flow/#42-visualize-neural-network-data","title":"4.2 Visualize Neural Network data","text":"<pre><code>_ = area_eval.plot_loss_curve(log_scale=True)\n</code></pre>"},{"location":"cylinder_flow/","title":"Steady Cylinder Flow","text":"<p>This notebook demonstrates solving steady-state Flow around cylinder with the same setup as this paper.</p>"},{"location":"cylinder_flow/#1-define-geometry-domain","title":"1. Define Geometry Domain","text":"<p>Set up the computational domain: a rectangle with a circular obstacle (cylinder). This defines the area for simulation.</p> <pre><code>import deepflow as df\nprint(\"Deepflow is runned on:\", df.device) # to change to cpu use df.device = 'cpu'\ndf.manual_seed(69) # for reproducibility\n\ncircle = df.geometry.circle(0.2, 0.2, 0.05)\nrectangle = df.geometry.rectangle([0,1.1], [0,0.41])\narea = rectangle - circle\ndomain = df.domain(area, circle.bound_list)\ndomain.show_setup()\n</code></pre>"},{"location":"cylinder_flow/#2-define-physics","title":"2. Define Physics","text":"<p>Define the Navier-Stokes equations for fluid flow and apply boundary conditions (e.g., no-slip walls, inlet velocity).</p> <pre><code>domain.bound_list[0].define_bc({'u': ['y', lambda x:  4*1*(0.41-x)*x/0.41**2], 'v': 0})\ndomain.bound_list[1].define_bc({'u': 0,'v': 0})\ndomain.bound_list[2].define_bc({'p': 0})\ndomain.bound_list[3].define_bc({'u': 0,'v': 0})\ndomain.bound_list[4].define_bc({'u': 0, 'v': 0})\ndomain.bound_list[5].define_bc({'u': 0, 'v': 0})\ndomain.area_list[0].define_pde(df.NavierStokes(U=1, L=1, mu=0.02, rho=1))\ndomain.show_setup()\n</code></pre> <p>Sample initial points for training.</p> <pre><code>domain.sampling_lhs(bound_sampling_res=[1000, 1000, 1000, 1000, 1000, 1000], area_sampling_res=[4000])\ndomain.show_coordinates(display_physics=False)\n</code></pre>"},{"location":"cylinder_flow/#3-train-the-pinn-model","title":"3. Train the PINN model","text":"<p>Define how collocation points are sampled during training.</p> <pre><code>def do_in_adam(epoch, model):\n    return\n\ndef do_in_lbfgs(epoch, model):\n    if epoch % 100 == 0 and epoch &gt; 0:\n        domain.sampling_R3(bound_sampling_res=[1000, 1000, 1000, 1000, 1000, 1000], area_sampling_res=[4000])\n        print(domain)\n</code></pre> <p>Train the model using Adam for initial training (faster convergence).</p> <pre><code>model0 = df.PINN(width=50, length=5, input_vars=['x','y'], output_vars=['u','v','p'])\n\n# Train the model\nmodel1, model1best = model0.train_adam(\n    learning_rate=0.004,\n    epochs=2000,\n    calc_loss=df.calc_loss_simple(domain),\n    threshold_loss=0.01,\n    do_between_epochs=do_in_adam)\n</code></pre> <p>Refine the model using LBFGS for higher precision.</p> <pre><code># Train the model\nmodel2 = model1best.train_lbfgs(\n    calc_loss=df.calc_loss_simple(domain),\n    epochs=450,\n    threshold_loss=0.0001,\n    do_between_epochs=do_in_lbfgs)\n\ndomain.show_coordinates()\n</code></pre> <p>Save or Load the model for later use</p> <pre><code>model2.save_as_pickle(\"model.pkl\")\nmodel2 = df.load_from_pickle(\"model.pkl\")\n</code></pre>"},{"location":"cylinder_flow/#4-visualization","title":"4. Visualization","text":""},{"location":"cylinder_flow/#41-visualize-area","title":"4.1 Visualize area","text":"<pre><code># Create object for evaluation\narea_eval = domain.area_list[0].evaluate(model2)\n# Sampling uniform points\narea_eval.sampling_area([300, 150])\n\narea_eval.plot_color('u', s=2, cmap='rainbow').savefig(\"colorplot_u.png\")\n_ = area_eval.plot_color('v', s=2, cmap='rainbow')\n_ = area_eval.plot_color('p', s=2, cmap='rainbow')\n_ = area_eval.plot_streamline('u', 'v', cmap = 'jet')\n_ = area_eval.plot('pde_residual')\n</code></pre>"},{"location":"cylinder_flow/#42-visualize-bound","title":"4.2 Visualize bound","text":"<pre><code># Create object for evaluation\nbound_visual = domain.bound_list[2].evaluate(model2)\nbound_visual.sampling_line(200) # Sampling uniform points\n_ = bound_visual.plot_color('u', cmap = 'rainbow')\n_ = bound_visual.plot(x_axis = 'y', y_axis='u')\n</code></pre>"},{"location":"cylinder_flow/#43-visualize-neural-network-data","title":"4.3 Visualize Neural Network data","text":"<pre><code>_ = bound_visual.plot_loss_curve(log_scale=True)\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>DeepFlow comes with several examples to help you get started.</p> <ul> <li>One-dimensional Burgers Equation</li> <li>Steady Channel Flow (Cavity) - Coming soon</li> <li>Steady Cylinder Flow - Coming soon</li> <li>2D Heat Equation - Coming soon</li> </ul> <p>You can find the source notebooks in the <code>examples/</code> directory of the repository.</p>"},{"location":"heat_eq/","title":"2D Unsteady Heat Equation","text":"<p>This notebook demonstrates solving Unsteady 2D Fourier's Heat Equation using PINNs.</p>"},{"location":"heat_eq/#1-define-geometry-domain","title":"1. Define Geometry Domain","text":"<p>Set up the computational domain.</p> <pre><code>import deepflow as df\nprint(\"Deepflow is runned on:\", df.device) # to change to cpu use df.device = 'cpu'\ndf.manual_seed(69) # for reproducibility\n\nrectangle = df.geometry.rectangle([0, 1], [0, 1])\n# It seems the example used a second rectangle for domain definition in logic but passed area_list\nrectangle1 = df.geometry.rectangle([0, 1], [0, 1])\ndomain = df.domain(rectangle, rectangle1.area_list)\ndomain.show_setup()\n</code></pre>"},{"location":"heat_eq/#2-define-physics","title":"2. Define Physics","text":"<p>Define the Heat equation and apply boundary conditions.</p> <pre><code># Define Boundary Conditions\ndomain.bound_list[0].define_bc({'u': 0})   # Inflow: u=1\ndomain.bound_list[1].define_bc({'u': 0})   # Inflow: u=1\ndomain.bound_list[2].define_bc({'u': 0})   # Inflow: u=1\ndomain.bound_list[3].define_bc({'u': 1})  # Wall: No slip\n\n# Define PDE (Heat Equation) and Initial Condition\ndomain.area_list[0].define_pde(df.pde.HeatEquation(0.1))\ndomain.area_list[1].define_ic({'u': 0})\n\n# Define time domain\nfor g in domain:\n    g.define_time(range_t = [0, 1], sampling_scheme='random')\n\ndomain.show_setup()\n</code></pre>"},{"location":"heat_eq/#2-generate-training-data","title":"2. Generate Training Data","text":"<p>Sample initial points for training. After sampling, Deepflow will automatically generate training datasets based on the defined physics.</p> <pre><code># Sample points: [Left, Bottom, Right, Top], [Interior]\ndomain.sampling_lhs([1000, 1000, 2000, 1000], [2000, 2000])\ndomain.show_coordinates(display_physics=True)\n</code></pre>"},{"location":"heat_eq/#3-train-the-model","title":"3. Train the Model","text":"<p>Define the resampling scheme during training. R3 scheme is recommended.</p> <pre><code>def do_in_adam(epoch, model):\n    if epoch % 1000 == 0 and epoch &gt; 0:\n        domain.sampling_R3([1000, 1000, 2000, 1000], [2000, 2000])\n        print(domain)\n\ndef do_in_lbfgs(epoch, model):\n    if epoch % 100 == 0 and epoch &gt; 0:\n        domain.sampling_R3([1000, 1000, 2000, 1000], [2000, 2000])\n        print(domain)\n</code></pre> <p>Train the model using Adam optimizer followed by L-BFGS optimizer.</p> <pre><code>model0 = df.PINN(width=32, length=4, input_vars=['x','y','t'], output_vars=['u'])\nmodel1, model1_best = model0.train_adam(\n    calc_loss = df.calc_loss_simple(domain),\n    learning_rate=0.004,\n    do_between_epochs=do_in_adam,\n    epochs=2000)\n\nmodel2 = model1_best.train_lbfgs(calc_loss = df.calc_loss_simple(domain), epochs=450, do_between_epochs=do_in_lbfgs, threshold_loss=5e-3)\n\ndomain.show_coordinates(display_physics=False)\n</code></pre>"},{"location":"heat_eq/#4-visualization","title":"4. Visualization","text":""},{"location":"heat_eq/#41-visualize-pde-area","title":"4.1 Visualize PDE area","text":"<pre><code># Evaluate the best model\nprediction = domain.area_list[0].evaluate(model2)\nprediction.sampling_area([200, 200])\nprediction.define_time(0.5)\n\n# Plot Temperature Field\n_ = prediction.plot('u', color='plasma')\n_.savefig('heat_eq_u.png', dpi=200)\n\n# Plot Training Loss\n_ =prediction.plot_loss_curve(log_scale=True, keys=['total_loss'])\n</code></pre>"},{"location":"heat_eq/#42-animate-the-solution-over-time","title":"4.2 Animate the solution over time","text":"<pre><code>prediction.sampling_area([160, 160])\nprediction.plot_animate('u', range_t = [0.02, 1.02], dt = 0.02, frame_interval=100, cmap='plasma', plot_type='scatter', s=1.7).save('heat_equation.mp4', dpi = 200)\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>This example demonstrates how to simulate Steady channel flow under 20 lines of code! We recommend using a Python notebook (<code>.ipynb</code>) for interactive experience.</p>"},{"location":"quickstart/#1-define-the-geometry-and-physics","title":"1. Define the Geometry and Physics","text":"<p><pre><code>import deepflow as df\n\n# Define the area and bounds\nrectangle = df.geometry.rectangle([0, 5], [0, 1])\ndomain = df.domain(rectangle)\n\ndomain.show_setup() # Display the domain setup\n</code></pre> <pre><code># Define Boundary Conditions\ndomain.bound_list[0].define_bc({'u': 1, 'v': 0})  # Inflow: u=1\ndomain.bound_list[1].define_bc({'u': 0, 'v': 0})  # Wall: No slip\ndomain.bound_list[2].define_bc({'p': 0})          # Outflow: p=0\ndomain.bound_list[3].define_bc({'u': 0, 'v': 0})  # Wall: No slip\n\n# Define PDE (Navier-Stokes)\ndomain.area_list[0].define_pde(df.pde.NavierStokes(U=0.0001, L=1, mu=0.001, rho=1000))\n\ndomain.show_setup() # Display the domain setup\n</code></pre> </p> <p><pre><code># Sample points: [Left, Bottom, Right, Top], [Interior]\ndomain.sampling_random([200, 400, 200, 400], [5000])\ndomain.show_coordinates(display_physics=True)\n</code></pre> </p>"},{"location":"quickstart/#2-create-and-train-the-model","title":"2. Create and Train the model","text":"<p><pre><code># Initialize the PINN model\nmodel0 = df.PINN(width=40, length=4)\n</code></pre> <pre><code># Train the model using Adam Optimizer\nmodel1 = model0.train_adam(\n    calc_loss=df.calc_loss_simple(domain),\n    learning_rate=0.001,\n    epochs=2000,)\n</code></pre></p>"},{"location":"quickstart/#3-visualize-results","title":"3. Visualize Results","text":"<p><pre><code># Evaluate the best model\nprediction = domain.area_list[0].evaluate(model1_best)\nprediction.sampling_area([500, 100])\n\n# Plot Velocity Field\n_ = prediction.plot_color('u', cmap='jet')\n\n# Plot Training Loss\n_ =prediction.plot_loss_curve()\n</code></pre> </p>"},{"location":"reference/","title":"API Reference","text":"<p>This page lists the main classes and functions available in <code>deepflow</code>.</p>"},{"location":"reference/#domain","title":"Domain","text":"<p>The domain module handles the creation and management of the computational domain, including geometry, boundary conditions, and sampling.</p>"},{"location":"reference/#domain_1","title":"<code>domain</code>","text":"<pre><code>def domain(*geometries) -&gt; ProblemDomain\n</code></pre> <p>Creates a <code>ProblemDomain</code> instance from a list of <code>Area</code> or <code>Bound</code> objects.</p> <p>Arguments: - <code>*geometries</code>: Can be single <code>Area</code>/<code>Bound</code> objects or lists of them.</p>"},{"location":"reference/#problemdomain","title":"<code>ProblemDomain</code>","text":"<p><pre><code>class ProblemDomain(bound_list, area_list):\n</code></pre> The main class managing the physics problem.</p> <p>Methods: - <code>sampling_uniform(bound_sampling_res, area_sampling_res)</code>: Samples points uniformly. - <code>sampling_random(bound_sampling_res, area_sampling_res)</code>: Samples points randomly. - <code>sampling_lhs(bound_sampling_res, area_sampling_res)</code>: Samples points using Latin Hypercube Sampling. - <code>sampling_R3(bound_sampling_res, area_sampling_res)</code>: Samples points using R3 refinement. - <code>show_setup()</code>: Plots the domain geometry and boundary conditions. - <code>show_coordinates(display_physics=False)</code>: Plots the sampled collocation points.</p>"},{"location":"reference/#calc_loss_simple","title":"<code>calc_loss_simple</code>","text":"<p><pre><code>def calc_loss_simple(domain: ProblemDomain) -&gt; callable\n</code></pre> Returns a loss function that calculates the weighted sum of boundary and PDE losses for the given domain.</p>"},{"location":"reference/#geometry","title":"Geometry","text":"<p>The <code>deepflow.geometry</code> module provides helper functions to create 1D and 2D geometries.</p>"},{"location":"reference/#rectangle","title":"<code>rectangle</code>","text":"<p><pre><code>def rectangle(range_x: List[float], range_y: List[float]) -&gt; Area\n</code></pre> Creates a rectangular area.</p>"},{"location":"reference/#circle","title":"<code>circle</code>","text":"<p><pre><code>def circle(x: float, y: float, r: float) -&gt; Area\n</code></pre> Creates a circular area.</p>"},{"location":"reference/#bound","title":"<code>Bound</code>","text":"<p>Represents a boundary (e.g., line segment).</p>"},{"location":"reference/#area","title":"<code>Area</code>","text":"<p>Represents a 2D area. Supports subtraction (e.g., <code>rect - circle</code>).</p>"},{"location":"reference/#pde","title":"PDE","text":"<p>The <code>deepflow.pde</code> module contains standard Partial Differential Equations.</p>"},{"location":"reference/#navierstokes","title":"<code>NavierStokes</code>","text":"<p><pre><code>class NavierStokes(U, L, mu, rho)\n</code></pre> 2D Incompressible Navier-Stokes equations.</p>"},{"location":"reference/#burgersequation1d","title":"<code>BurgersEquation1D</code>","text":"<p><pre><code>class BurgersEquation1D(nu)\n</code></pre> 1D Burgers' equation.</p>"},{"location":"reference/#heatequation","title":"<code>HeatEquation</code>","text":"<p><pre><code>class HeatEquation(alpha)\n</code></pre> 2D Heat equation.</p>"},{"location":"reference/#neural-network","title":"Neural Network","text":""},{"location":"reference/#pinn","title":"<code>PINN</code>","text":"<p><pre><code>class PINN(width, length, input_vars, output_vars, activation=nn.Tanh())\n</code></pre> Physics-Informed Neural Network model.</p> <p>Methods: - <code>train_adam(calc_loss, learning_rate, epochs, ...)</code>: Train using Adam optimizer. - <code>train_lbfgs(calc_loss, epochs, ...)</code>: Train using L-BFGS optimizer. - <code>save_as_pickle(path)</code>: Save model. - <code>load_from_pickle(path)</code>: Load model.</p>"},{"location":"reference/#evaluation","title":"Evaluation","text":""},{"location":"reference/#evaluator-visualizer","title":"<code>Evaluator</code> (Visualizer)","text":"<p>Returned by <code>domain.area_list[i].evaluate(model)</code>.</p> <p>Methods: - <code>sampling_area(res_list)</code>: Sample points for visualization. - <code>plot(key)</code>: Plot a variable. - <code>plot_color(key)</code>: Plot a variable as a color map. - <code>plot_streamline(u, v)</code>: Plot streamlines. - <code>plot_loss_curve()</code>: Plot loss history. - <code>plot_animate(...)</code>: Create animation (for transient problems).</p>"}]}