{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"DeepFlow: Physics-Informed Neural Networks for Fluid Dynamics","text":"<p>DeepFlow is a user-friendly framework for solving partial differential equations (PDEs), such as the Navier-Stokes equations, using Physics-Informed Neural Networks (PINNs). It provides a CFD-solver-style workflow to make PINN-based simulations accessible and straightforward.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u27c1 Physics-Attached Geometry: AUTO GENERATE TRAINING DATA by explicitly attach physics and neural network to geometries.</li> <li>\ud83d\udd27 CFD-Solver Style: Straightforward workflow similar to CFD software.</li> <li>\ud83d\udcca Built-in Visualization: Tools to evaluate and plot results.</li> <li>\ud83d\ude80 GPU Acceleration: Enable GPU for faster training.</li> <li>Flexible Domain Definition: Easily define complex 2D geometries.</li> </ul>"},{"location":"#current-implementations","title":"Current Implementations","text":"<ul> <li>Supported problems: solving forward partial differential equations (PDEs)<ul> <li>transient &amp; steady 2D imcompressible Navier-Stokes equations, 2D Fourier Heat equation, Burgers' equation</li> </ul> </li> <li>Sampling methods: Uniform, Random, Latin Hypercube Sampling, RAR-G [0], R3 [1]</li> <li>2D Geometries: Custom functions, Rectangle, Circle, Polygon, and combinations &amp; subtractions.</li> <li>Hard Boundary Conditions: Automatic Hard BC w.r.t. to geometry.</li> <li>Neural Network Architectures: Fully connected feedforward networks (FNN).</li> <li>Optimizers: Adam, L-BFGS</li> <li>Backend: PyTorch</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install DeepFlow via pip:</p> <pre><code>pip install deepflow\n</code></pre> <p>For development or to build from source:</p> <pre><code>git clone https://github.com/YoYo-XYZ/deepflow.git\ncd deepflow\npip install -e .\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python &gt;= 3.8</li> <li>PyTorch &gt;= 1.7.0</li> <li>NumPy &gt;= 1.19.0</li> <li>Matplotlib &gt;= 3.3.0</li> <li>SymPy &gt;= 1.5.0</li> <li>SciPy &gt;= 1.5.0</li> <li>Ultrplot &gt;= 1.0.0</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Check out the Quick Start guide to simulate Steady channel flow under 20 lines of code!</p>"},{"location":"#examples","title":"Examples","text":"<p>See Examples for more use cases including Burgers' Equation, Heat Equation, and Cavity Flow.</p>"},{"location":"#deepflow-milestones","title":"DeepFlow Milestones","text":"<p>...</p>"},{"location":"burgers_eq/","title":"1D Burgers Equation DEMO code","text":"<p>This notebook demonstrates solving 1D Burgers Equation (spatial xy version) using PINNs.</p> <pre><code>import deepflow as df\nprint(\"Deepflow is runned on:\", df.device) # to change to cpu use df.device = 'cpu'\ndf.manual_seed(69) # for reproducibility\n</code></pre> <pre><code>Deepflow is runned on: cuda\n</code></pre>"},{"location":"burgers_eq/#1-define-geometry-domain","title":"1. Define Geometry Domain","text":"<p>Set up the computational domain</p> <pre><code>area = df.geometry.rectangle([-1, 1], [0, 1])\nline_ic = df.geometry.line_horizontal(y=0, range_x=[-1,1])\nline_bc1 = df.geometry.line_vertical(x=-1, range_y=[0,1])\nline_bc2 = df.geometry.line_vertical(x=1, range_y=[0,1])\ndomain = df.domain(area.area_list, line_ic, line_bc1, line_bc2)\ndomain.show_setup()\n</code></pre> <p></p>"},{"location":"burgers_eq/#2-define-physics","title":"2. Define Physics","text":"<p>Define the Burgers eq (spatial version) apply boundary conditions.</p> <pre><code># Define PDE\nfrom torch import sin, pi\ndomain.area_list[0].define_pde(df.pde.BurgersEquation1D(nu=0.01/pi))\ndomain.bound_list[0].define_bc({'u':['x', lambda x: -sin(pi * x)]})\ndomain.bound_list[1].define_bc({'u': 0})\ndomain.bound_list[2].define_bc({'u': 0})\n</code></pre>"},{"location":"burgers_eq/#2-generate-training-data","title":"2. Generate Training Data","text":"<p>Sample initial points for training. After sampling, Deepflow will automatically generate training datasets based on the defined physics.</p> <pre><code># Sample points: [Left, Bottom, Right, Top], [Interior]\ndomain.sampling_lhs([2000, 1000, 1000], [4000])\ndomain.show_coordinates(display_physics=True)\n</code></pre> <p></p>"},{"location":"burgers_eq/#3-train-the-model","title":"3. Train the Model","text":"<p>Define the resampling scheme during training. R3 scheme is recommended.</p> <pre><code>def do_in_adam(epoch, model):\n    if epoch % 500 == 0 and epoch &gt; 0:\n        domain.sampling_R3([2000, 1000, 1000], [4000])\n        print(domain)\n\ndef do_in_lbfgs(epoch, model):\n    if epoch % 100 == 0 and epoch &gt; 0:\n        domain.sampling_R3([2000, 1000, 1000], [4000])\n        print(domain)\n</code></pre> <p>Train the model using Adam optimizer followed by L-BFGS optimizer.</p> <pre><code>model0 = df.PINN(input_vars=['x', 'y'], output_vars=['u'], width=16, length=4)\n\nmodel1, model1_best = model0.train_adam(\n    calc_loss = df.calc_loss_simple(domain),\n    learning_rate=0.015,\n    epochs=4000,\n    do_between_epochs=do_in_adam)\n</code></pre> <pre><code>Epoch: 1, total_loss: 0.63708, bc_loss: 0.63691, pde_loss: 0.00018\nEpoch: 200, total_loss: 0.10178, bc_loss: 0.05901, pde_loss: 0.04277\nEpoch: 400, total_loss: 0.07294, bc_loss: 0.04452, pde_loss: 0.02842\nnumber of bound : ['0: 3065', '1: 1693', '2: 1482']\nnumber of area : ['0: 5407']\nEpoch: 600, total_loss: 0.10885, bc_loss: 0.07805, pde_loss: 0.03080\nEpoch: 800, total_loss: 0.01511, bc_loss: 0.00641, pde_loss: 0.00870\nEpoch: 1000, total_loss: 0.01650, bc_loss: 0.00472, pde_loss: 0.01178\nnumber of bound : ['0: 3800', '1: 2198', '2: 1813']\nnumber of area : ['0: 6625']\nEpoch: 1200, total_loss: 0.01325, bc_loss: 0.00356, pde_loss: 0.00969\nEpoch: 1400, total_loss: 0.00802, bc_loss: 0.00367, pde_loss: 0.00435\nnumber of bound : ['0: 4617', '1: 2747', '2: 2254']\nnumber of area : ['0: 7925']\nEpoch: 1600, total_loss: 0.00648, bc_loss: 0.00290, pde_loss: 0.00358\nEpoch: 1800, total_loss: 0.00302, bc_loss: 0.00102, pde_loss: 0.00201\nEpoch: 2000, total_loss: 0.00735, bc_loss: 0.00360, pde_loss: 0.00375\nnumber of bound : ['0: 5493', '1: 3284', '2: 2527']\nnumber of area : ['0: 8984']\nEpoch: 2200, total_loss: 0.00176, bc_loss: 0.00045, pde_loss: 0.00131\nEpoch: 2400, total_loss: 0.00930, bc_loss: 0.00278, pde_loss: 0.00652\nnumber of bound : ['0: 6255', '1: 3747', '2: 2913']\nnumber of area : ['0: 9964']\nEpoch: 2600, total_loss: 0.02079, bc_loss: 0.00154, pde_loss: 0.01925\nEpoch: 2800, total_loss: 0.00742, bc_loss: 0.00078, pde_loss: 0.00664\nEpoch: 3000, total_loss: 0.00273, bc_loss: 0.00114, pde_loss: 0.00159\nnumber of bound : ['0: 6923', '1: 4220', '2: 3455']\nnumber of area : ['0: 10893']\nEpoch: 3200, total_loss: 0.00098, bc_loss: 0.00024, pde_loss: 0.00074\nEpoch: 3400, total_loss: 0.00073, bc_loss: 0.00017, pde_loss: 0.00056\nnumber of bound : ['0: 7651', '1: 4733', '2: 3835']\nnumber of area : ['0: 11927']\nEpoch: 3600, total_loss: 0.01580, bc_loss: 0.00201, pde_loss: 0.01380\nEpoch: 3800, total_loss: 0.00503, bc_loss: 0.00171, pde_loss: 0.00332\nEpoch: 4000, total_loss: 0.04200, bc_loss: 0.01015, pde_loss: 0.03185\nnumber of bound : ['0: 8525', '1: 5214', '2: 4219']\nnumber of area : ['0: 12743']\n</code></pre> <pre><code>model2 = model1_best.train_lbfgs(calc_loss = df.calc_loss_simple(domain), epochs=500, do_between_epochs=do_in_lbfgs)\n</code></pre> <pre><code>Epoch: 3945, total_loss: 0.00049, bc_loss: 0.00009, pde_loss: 0.00041\nEpoch: 3995, total_loss: 0.00002, bc_loss: 0.00000, pde_loss: 0.00002\nTraining interrupted by user.\n</code></pre> <pre><code>domain.show_coordinates(display_physics=False)\n</code></pre> <p></p>"},{"location":"burgers_eq/#4-visualization","title":"4. Visualization","text":"<pre><code># Evaluate the best model\nprediction = domain.area_list[0].evaluate(model2)\n# Sampling uniform points\nprediction.sampling_area([500, 250])\n</code></pre>"},{"location":"burgers_eq/#41-visualize-pde-area","title":"4.1 Visualize PDE area","text":"<pre><code># Plot Velocity Field\nprediction.plot_color('u', cmap = 'jet', s=0.3).savefig('u_field.png')\n_ = prediction.plot_color('pde_residual', cmap = 'rainbow', s=0.3)\n_ = prediction.plot('pde_residual')\n_ = prediction.plot_loss_curve(log_scale=True)\n</code></pre>"},{"location":"burgers_eq/#42-visualize-u-at-y-075","title":"4.2 Visualize u at y = 0.75","text":"<pre><code>line = df.geometry.line_horizontal(y=0.75, range_x=[-1, 1])\nprediction = line.evaluate(model2)\nprediction.sampling_line(500)\n_ = prediction.plot(y_axis = 'u')\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>This example demonstrates how to simulate Steady channel flow under 20 lines of code! We recommend using a Python notebook (<code>.ipynb</code>) for interactive experience.</p>"},{"location":"quickstart/#1-define-the-geometry-and-physics","title":"1. Define the Geometry and Physics","text":"<p><pre><code>import deepflow as df\n\n# Define the area and bounds\nrectangle = df.geometry.rectangle([0, 5], [0, 1])\ndomain = df.domain(rectangle)\n\ndomain.show_setup() # Display the domain setup\n</code></pre> <pre><code># Define Boundary Conditions\ndomain.bound_list[0].define_bc({'u': 1, 'v': 0})  # Inflow: u=1\ndomain.bound_list[1].define_bc({'u': 0, 'v': 0})  # Wall: No slip\ndomain.bound_list[2].define_bc({'p': 0})          # Outflow: p=0\ndomain.bound_list[3].define_bc({'u': 0, 'v': 0})  # Wall: No slip\n\n# Define PDE (Navier-Stokes)\ndomain.area_list[0].define_pde(df.pde.NavierStokes(U=0.0001, L=1, mu=0.001, rho=1000))\n\ndomain.show_setup() # Display the domain setup\n</code></pre> </p> <p><pre><code># Sample points: [Left, Bottom, Right, Top], [Interior]\ndomain.sampling_random([200, 400, 200, 400], [5000])\ndomain.show_coordinates(display_physics=True)\n</code></pre> </p>"},{"location":"quickstart/#2-create-and-train-the-model","title":"2. Create and Train the model","text":"<p><pre><code># Initialize the PINN model\nmodel0 = df.PINN(width=40, length=4)\n</code></pre> <pre><code># Train the model using Adam Optimizer\nmodel1 = model0.train_adam(\n    calc_loss=df.calc_loss_simple(domain),\n    learning_rate=0.001,\n    epochs=2000,)\n</code></pre></p>"},{"location":"quickstart/#3-visualize-results","title":"3. Visualize Results","text":"<p><pre><code># Evaluate the best model\nprediction = domain.area_list[0].evaluate(model1_best)\nprediction.sampling_area([500, 100])\n\n# Plot Velocity Field\n_ = prediction.plot_color('u', cmap='jet')\n\n# Plot Training Loss\n_ =prediction.plot_loss_curve()\n</code></pre> </p>"}]}